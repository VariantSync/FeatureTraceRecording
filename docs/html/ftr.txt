-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package ftr

module Defunctor
class Defunctor f
demap :: Defunctor f => (f a -> f b) -> a -> b
instance Defunctor.Defunctor GHC.Maybe.Maybe
instance Defunctor.Defunctor []


-- | Module for representing context-free grammars.
module Grammar

-- | Classification of nodes for feature traces and presence condition.
--   (See Section 3.1 in the paper.)
data NodeType
Mandatory :: NodeType
Optional :: NodeType
Wrapper :: NodeType

-- | Type class for context-free grammars.
class Show g => Grammar g

-- | Tells for each grammar symbol which node type it has (e.g., if it is
--   <a>Mandatory</a> in the AST).
nodetypeof :: Grammar g => g -> NodeType
instance GHC.Classes.Eq Grammar.NodeType
instance GHC.Show.Show Grammar.NodeType


-- | A collection of functions that modify lists.
module ListUtil

-- | Returns the head of the given list as Just or Nothing, iff the list is
--   empty.
safehead :: [a] -> Maybe a

-- | Returns a continuous sublist within the given range [i, j].
getRange :: Int -> Int -> [a] -> [a]

-- | Inserts the given element into the given list at the given index.
--   Subsequent elements will be pushed by one.
insertAtIndex :: Int -> a -> [a] -> [a]

-- | Inserts all elements from the first list into the second list at the
--   given index. Similar to <a>insertAtIndex</a> but inserts all elements
--   of a list rather than just a single element.
insertListAtIndex :: Int -> [a] -> [a] -> [a]

-- | Removes the element at given index from the given list.
removeIndex :: Int -> [a] -> [a]

-- | Removes all elements within the given range [i, j] from the given
--   list.
removeRange :: Int -> Int -> [a] -> [a]

-- | Removes all duplicates from the given list. If two elements are equal
--   (w.r.t. to <tt>Eq</tt>), the first one will be kept and the second one
--   discarded.
removeDuplicates :: Eq a => [a] -> [a]

module Logic
class Logic l
ltrue :: Logic l => l
lfalse :: Logic l => l
lvalues :: Logic l => [l]
lnot :: Logic l => l -> l
land :: Logic l => [l] -> l
lor :: Logic l => [l] -> l
limplies :: Logic l => l -> l -> l
lequals :: Logic l => l -> l -> l
leval :: Logic l => (l -> l) -> l -> l

module Propositions
data PropositionalFormula a
PTrue :: PropositionalFormula a
PFalse :: PropositionalFormula a
PVariable :: a -> PropositionalFormula a
PNot :: PropositionalFormula a -> PropositionalFormula a
PAnd :: [PropositionalFormula a] -> PropositionalFormula a
POr :: [PropositionalFormula a] -> PropositionalFormula a
type Assignment a = a -> Bool
eval :: Assignment a -> PropositionalFormula a -> Bool
liftBool :: Bool -> PropositionalFormula a
isPTrue :: PropositionalFormula a -> Bool
isPFalse :: PropositionalFormula a -> Bool
isLiteral :: PropositionalFormula a -> Bool
isCNF :: PropositionalFormula a -> Bool
toCNF :: PropositionalFormula a -> PropositionalFormula a
lazyToCNF :: PropositionalFormula a -> PropositionalFormula a
toCNFClauseList :: PropositionalFormula a -> [PropositionalFormula a]
toDNFClauseList :: PropositionalFormula a -> [PropositionalFormula a]
toNNF :: PropositionalFormula a -> PropositionalFormula a
cartesianOr :: [PropositionalFormula a] -> [PropositionalFormula a] -> [PropositionalFormula a]
simplify :: PropositionalFormula a -> PropositionalFormula a
clausifyCNF :: Show a => (a -> a) -> (() -> a) -> PropositionalFormula a -> [[a]]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Propositions.PropositionalFormula a)
instance Logic.Logic (Propositions.PropositionalFormula a)
instance GHC.Base.Functor Propositions.PropositionalFormula
instance GHC.Show.Show a => GHC.Show.Show (Propositions.PropositionalFormula a)

module NullPropositions
type NullableFormula a = Maybe (PropositionalFormula a)
isnull :: NullableFormula a -> Bool
notnull :: NullableFormula a -> Bool
assure :: NullableFormula a -> PropositionalFormula a
nullable_simplify :: NullableFormula a -> NullableFormula a
prettyPrint :: Show a => Maybe a -> String
instance Logic.Logic a => Logic.Logic (GHC.Maybe.Maybe a)

module Feature
type Feature = String
toFeature :: String -> Feature
type NonNullFeatureFormula = PropositionalFormula Feature
type FeatureFormula = NullableFormula Feature

module FeatureColour
type ColourPalette a m = a -> Color m
type FeatureColourPalette m = ColourPalette Feature m
type FeatureFormulaColourPalette m = FeatureFormula -> Color m
defaultFeatureFormulaColouring :: MonadColorPrinter m => FeatureColourPalette m -> FeatureFormulaColourPalette m

module Truthtable
unarytable :: Logic a => (a -> a) -> [a] -> [a]
cartesian :: [a] -> [b] -> [(a, b)]
binarytable :: Logic a => (a -> a -> a) -> [a] -> [a]
binarify :: ([a] -> b) -> a -> a -> b
hfillto :: Int -> String -> String
defaultlinewidth :: Int
defaulthfillto :: String -> String
prettyunarytable :: (Logic a, Show a) => [a] -> (a -> a) -> String -> String
prettybinarytable :: (Logic a, Show a) => [a] -> (a -> a -> a) -> String -> String
generatetruthtablesfor :: (Logic a, Show a) => [a] -> String


-- | Module representing universable unique identifiers (UUID).
module UUID

-- | A universable unique identifiers (UUID) realised as an integer.
type UUID = Int

-- | Computes successor UUID of the current UUID.
next :: State UUID ()

-- | Converts a UUID to an int.
toInt :: UUID -> Int

-- | An invalid value for UUID that can be used to represent invalid
--   states.
epsilon :: UUID


-- | A module containing various utility functions.
module Util

-- | Generates a string of <i>i</i> spaces where <i>i</i> is the given
--   indent. For example <tt>genIndent 4</tt> returns <tt>" "</tt>.
genIndent :: Int -> String

-- | Returns <tt>x</tt> iff the given Maybe is <tt>Just x</tt>. Otherwise,
--   returns the value produced by the given generator function.
safeFromJust :: Maybe a -> (() -> a) -> a

-- | Folds the given list after reversing it.
reversefoldr :: (a -> b -> b) -> b -> [a] -> b

-- | Generates parenthesis aroung the given string iff the given bool is
--   true.
parenIf :: Bool -> String -> String

-- | Filters the given Maybe. If the maybe's element satisfies the given
--   predicate, the element will be kept. Otherwise, returns
--   <tt>Nothing</tt>.
takeIf :: (a -> Bool) -> Maybe a -> Maybe a

-- | Lifts a value to a Maybe based on a predicate. Iff the element
--   satisfies the predicate, the result is <tt>Nothing</tt>. Otherwise
--   returns the <tt>Just</tt> the element.
nothingIf :: (a -> Bool) -> a -> Maybe a

-- | Removes the first and the last element of a list.
removeFirstAndLast :: [a] -> [a]

-- | If the given string starts and ends with quotes <tt>"</tt> (i.e., it
--   is of the form <tt>""something""</tt>), those parenthesis will be
--   removed (i.e., turned to just <tt>"something"</tt>). This is used for
--   showing strings from a polymorphic context.
removeQuotes :: String -> String


-- | Implementation of a rose tree (i.e., a tree whose nodes can have an
--   arbitrary amount of children, including 0).
module Tree

-- | Rose tree of elements of type a where children of nodes are given as
--   lists.
data Tree a
Tree :: a -> [Tree a] -> Tree a

-- | Returns true iff the given tree is a leaf (i.e., it has no children).
isleaf :: Tree a -> Bool

-- | Returns the value stored in the root of the given tree.
element :: Tree a -> a

-- | Finds a subtree in the given tree (first argument) whose root has the
--   given value (second argument). Throws an error iff no such tree
--   exists.
tree :: (Eq a, Show a) => Tree a -> a -> Tree a

-- | Same as <a>tree</a> but returns <tt>Nothing</tt> in the error case
--   (i.e., when no subtree contains the given value).
safetree :: Eq a => Tree a -> a -> Maybe (Tree a)

-- | Transforms a tree into a set. The returned set contains exactly the
--   values previously held in the tree.
toset :: Ord a => Tree a -> Set a

-- | Find a subtree in the given tree (first argument) whose root matches
--   the predicate (second argument).
find :: (Tree a -> Bool) -> Tree a -> Maybe (Tree a)

-- | Same as <a>find</a> but takes a predicate over elements instead of a
--   predicate over trees to identify the subtree of interest.
findByNode :: (a -> Bool) -> Tree a -> Maybe (Tree a)

-- | Returns the parent of the given node (second argument) in the given
--   tree (first argument). The returned parent is a subtree of the first
--   given tree and has the second given tree as child. Throws an error iff
--   no parent exists.
parent :: Eq a => Tree a -> Tree a -> Maybe (Tree a)
ancestors :: Eq a => Tree a -> Tree a -> [Tree a]

-- | Applies the given function to each node from bottom to top (i.e.,
--   leaves are converted first, root last).
manipulate :: (Tree a -> Tree a) -> Tree a -> Tree a
filterTrees :: (Tree a -> Bool) -> Tree a -> Tree a
filterNodes :: (Tree a -> Bool) -> Tree a -> Tree a

-- | Pretty print function that folds the tree into a monoidial type
--   <tt>b</tt>. <tt>b</tt> is the type that is the output of the print
--   (e.g., String or Text). First argument is the length of the indent in
--   spaces (e.g., 2 will produce an indent of <tt>" "</tt> per level).
--   Second argument is a function that lifts strings to the output type b
--   (e.g., a constructor of <tt>b</tt> accepting a string). Third argument
--   is a function to convert tree elements to the output type (e.g.,
--   <tt>show</tt> if <tt>b</tt> is <tt>String</tt>).
prettyPrint :: (Show a, Monoid b) => Int -> (String -> b) -> (a -> b) -> Tree a -> b
instance Data.Traversable.Traversable Tree.Tree
instance GHC.Classes.Eq a => GHC.Classes.Eq (Tree.Tree a)
instance GHC.Show.Show a => GHC.Show.Show (Tree.Tree a)
instance GHC.Base.Functor Tree.Tree
instance Data.Foldable.Foldable Tree.Tree
instance GHC.Base.Applicative Tree.Tree


-- | Module for Abstract Syntax Trees (ASTs) that are <a>Tree</a>s with a
--   fixed node type.
module AST

-- | Node type of ASTs.
data Node g a
Node :: a -> g -> UUID -> Node g a

-- | The value that is encapsulated by a node. Most of the time this is a
--   <tt>String</tt> referring to source code statements.
[value] :: Node g a -> a

-- | The grammar rule this node was parsed from. <tt>g</tt> should be an
--   instance of <a>Grammar</a>.
[grammartype] :: Node g a -> g

-- | A unique identifier to trace nodes across several versions of ASTs.
[uuid] :: Node g a -> UUID

-- | Type for abstract syntax trees. It is a tree whose nodes are
--   associated to a value, a grammar type and a UUID.
type AST g a = Tree (Node g a)

-- | Returns the node type of a nodes grammar type.
optionaltype :: Grammar g => Node g a -> NodeType

-- | Creates a new node from a value and a type by generating a new UUID
--   for it.
node :: Grammar g => a -> g -> State UUID (Node g a)

-- | Returns the UUID of an ast's root.
uuidOf :: AST g a -> UUID

-- | Finds a subtree in the given AST whose root has the given UUID.
--   Returns <tt>Nothing</tt> iff no such subtree exists.
findById :: UUID -> AST g a -> Maybe (AST g a)

-- | Finds a subtree in the given AST whose root has the given value.
--   Returns <tt>Nothing</tt> iff no such subtree exists.
findByValue :: Eq a => a -> AST g a -> Maybe (AST g a)

-- | Finds a subtree in the given AST whose root has the given grammar
--   type. Returns <tt>Nothing</tt> iff no such subtree exists.
findByGrammarType :: Eq g => g -> AST g a -> Maybe (AST g a)

-- | Returns all ancestors of a given subtree (second argument) in the
--   given tree (first argument), that are optional (i.e., their
--   <a>optionaltype</a> is <tt>Optional</tt>).
optionalAncestors :: (Eq a, Grammar g) => AST g a -> AST g a -> [AST g a]
instance GHC.Classes.Eq (AST.Node g a)
instance GHC.Classes.Eq a => GHC.Classes.Ord (AST.Node g a)
instance GHC.Base.Functor (AST.Node g)
instance (Grammar.Grammar g, GHC.Show.Show a) => GHC.Show.Show (AST.Node g a)

module SAT
sat :: (Show a, Ord a) => PropositionalFormula a -> Bool
satAssignment :: (Show a, Ord a) => PropositionalFormula a -> Maybe (Assignment a)
tautCounterExample :: (Show a, Ord a) => PropositionalFormula a -> Maybe (Assignment a)
taut :: (Show a, Ord a) => PropositionalFormula a -> Bool
contradicts :: (Show a, Ord a) => PropositionalFormula a -> Bool
toIntCNF :: Ord a => PropositionalFormula a -> ([[Int]], Bimap a Int)

module Simplify
removeRedundancy :: (Ord a, Show a) => PropositionalFormula a -> PropositionalFormula a -> PropositionalFormula a

module FeatureTrace
type FeatureTrace g a = Node g a -> FeatureFormula
emptyTrace :: FeatureTrace g a
simplifyFeatureTrace :: (Grammar g, Show a, Eq a) => FeatureTrace g a -> AST g a -> FeatureTrace g a
simplifyFeatureTraceOfNodes :: (Grammar g, Show a, Eq a) => FeatureTrace g a -> AST g a -> Set (Node g a) -> FeatureTrace g a
pc :: (Grammar g, Show a, Eq a) => AST g a -> FeatureTrace g a -> Node g a -> FeatureFormula
pc_parentpart :: (Grammar g, Show a, Eq a) => AST g a -> FeatureTrace g a -> Node g a -> FeatureFormula
augmentWithTrace :: (Node g a -> FeatureFormula) -> AST g a -> Tree (FeatureFormula, Node g a)
prettyPrint :: (Grammar g, Show a) => Tree (FeatureFormula, Node g a) -> String

module TikzExport
astToTikzWithTraceDefault :: (Eq a, Show a, Grammar g) => FeatureTrace g a -> AST g a -> String
featuresToTikzClass :: FeatureFormula -> String
astToTikzWithTrace :: (AST g a -> String) -> (AST g a -> Node g a -> FeatureTrace g a -> String) -> FeatureTrace g a -> AST g a -> String
astToTikz :: (AST g a -> String) -> (AST g a -> String) -> AST g a -> String
astToTikzRecursive :: Int -> (AST g a -> String) -> (AST g a -> String) -> AST g a -> String
tikzifyName :: String -> String


-- | Module for edits to ASTs.
module Edits

-- | Each edit is associated to a type depending on what it does.
data EditType

-- | <tt>Identity</tt> edits do nothing to the AST (they are noops).
Identity :: EditType

-- | <tt>TraceOnly</tt> are edits that do not alter the AST but have a
--   non-empty delta. This delta is used to descibe side-effects that
--   should be applied to all nodes in the delta (e.g., change their
--   feature mapping).
TraceOnly :: EditType

-- | <tt>Insert</tt> edits only add nodes to a tree.
Insert :: EditType

-- | <tt>Delete</tt> edits only remove nodes from a tree.
Delete :: EditType

-- | <tt>Move</tt>s only relocate nodes within the same tree.
Move :: EditType

-- | <tt>Update</tt>s only change the contents of one or more nodes without
--   altering the tree structure.
Update :: EditType

-- | An edit to an AST.
data Edit g a
Edit :: EditType -> String -> (AST g a -> AST g a) -> (AST g a -> Set (Node g a)) -> Edit g a

-- | The type of this edit classifying its behaviour.
[edittype] :: Edit g a -> EditType

-- | The name of this edit. Used for debugging and printing.
[name] :: Edit g a -> String

-- | Applies the edit to an AST, yielding the edited AST.
[run] :: Edit g a -> AST g a -> AST g a

-- | Computs the set of all nodes that will be altered (inserted, deleted,
--   moved, updated ...) when applying the edit to a given AST.
[delta] :: Edit g a -> AST g a -> Set (Node g a)

-- | An <tt>EditScript</tt> is a sequence of edits that should be applied
--   in order to a single AST.
type EditScript g a = [Edit g a]

-- | Runs an entire edit script on a given AST. If curried, turns an edit
--   script into one single function that can run that script on any AST.
foldEditScript :: EditScript g a -> AST g a -> AST g a

-- | The identity of edits. Does nothing and has an empty delta for all
--   trees.
edit_identity :: Edit g a
edit_trace_only :: Set (Node g a) -> Edit g a

-- | Inserts a subtree into another tree. The given tree (first argument)
--   will become the <tt>i</tt>-th child of the node with the given UUID.
edit_ins_tree :: Eq a => AST g a -> UUID -> Int -> Edit g a

-- | Delete the node with the given UUID v and move its children up (such
--   that they become children of the deleted node's parent).
edit_del_node :: Eq a => UUID -> Edit g a

-- | Delete the entire subtree whose root has the given id.
edit_del_tree :: Eq a => UUID -> Edit g a

-- | Moves the subtree <tt>s</tt> with the given root (first argument).
--   <tt>s</tt> will become the i-th child of the node with the given id
--   (second argument).
edit_move_tree :: (Grammar g, Eq a, Show a) => UUID -> UUID -> Int -> Edit g a

-- | Updates the node with the given UUID to have a new grammar type and a
--   new value. The node will keep its UUID (i.e., not get a new uuid as it
--   is still associated to the same previous node.
edit_update :: (Grammar g, Show a, Eq a) => UUID -> g -> a -> Edit g a
instance GHC.Show.Show Edits.EditType
instance GHC.Classes.Eq Edits.EditType
instance GHC.Show.Show (Edits.Edit g a)

module FeatureTraceRecording
type FeatureContext = FeatureFormula
type RecordedEdit g a = (Edit g a, FeatureContext)
type History g a = [RecordedEdit g a]
type Version g a = (FeatureTrace g a, AST g a)
type RecordingFunction g a = RecordedEdit g a -> Version g a -> FeatureTrace g a
type FeatureTraceRecording g a = EditType -> RecordingFunction g a
runFTR :: (Show a, Eq a) => FeatureTraceRecording g a -> Version g a -> History g a -> Version g a
runFTRWithIntermediateSteps :: (Show a, Eq a) => FeatureTraceRecording g a -> Version g a -> History g a -> [Version g a]

module DefaultFeatureTraceRecording
defaultFeatureTraceRecording :: (Grammar g, Show a, Eq a) => FeatureTraceRecording g a
nullifyMandatory :: Grammar g => RecordingFunction g a -> RecordingFunction g a
removeTheRedundanciesWeIntroduced :: (Grammar g, Eq a, Show a) => RecordingFunction g a -> RecordingFunction g a
ftr_id :: RecordingFunction g a
ftr_trace :: Eq a => RecordingFunction g a
ftr_ins :: (Show a, Eq a) => RecordingFunction g a
ftr_del :: (Grammar g, Eq a, Show a) => RecordingFunction g a
ftr_move :: (Show a, Eq a) => RecordingFunction g a
ftr_up :: (Eq a, Show a) => RecordingFunction g a

module Example
data Example m g a
Example :: String -> Version g a -> History g a -> FeatureFormulaColourPalette m -> Example m g a
[name] :: Example m g a -> String
[startVersion] :: Example m g a -> Version g a
[history] :: Example m g a -> History g a
[colours] :: Example m g a -> FeatureFormulaColourPalette m
runExample :: (Grammar g, Show a, Eq a) => FeatureTraceRecording g a -> Example m g a -> [Version g a]
runExampleWithDefaultFTR :: (Grammar g, Show a, Eq a) => Example m g a -> [Version g a]


-- | Module for pretty printing of ASTs.
module ASTPrettyPrinter

-- | An ASTPrettyPrinter can pretty print ASTs of a certain grammar.
class Show g => ASTPrettyPrinter g

-- | Pretty prints the given AST (last argument) to another type b (e.g.,
--   <tt>String</tt>). Parameters are: * the start indent (e.g.,
--   <tt>""</tt>), * an indent generator that can generate an indent of a
--   certain width within the context of printing a certain node (e.g.,
--   <tt>(_ i -&gt; genIndent i)</tt>), * a function to lift strings to the
--   output type b within the context of printing a certain node, * a
--   function print nodes, and * the AST to print.
prettyPrint :: (ASTPrettyPrinter g, Monoid b) => b -> (Node g a -> Int -> b) -> (Node g a -> String -> b) -> (Node g a -> b) -> AST g a -> b

-- | Default implementation for pretty printing an AST to a
--   <tt>String</tt>.
showCode :: (Show a, Grammar g, ASTPrettyPrinter g) => AST g a -> String

-- | Alias for <a>prettyPrint</a>.
showCodeAs :: (Monoid b, ASTPrettyPrinter g) => b -> (Node g a -> Int -> b) -> (Node g a -> String -> b) -> (Node g a -> b) -> AST g a -> b


-- | Example implementation of a context free grammar. This example
--   represents a simplified subset of the Java programming language. It
--   contains the <a>Grammar</a> implementation as well as functions to
--   construct an AST in this sub-language.
module SimpleJava

-- | Simplified subset of the Java grammar.
data SimpleJavaGrammar

-- | Rule for method definitions.
SJava_MethodDef :: SimpleJavaGrammar

-- | Rule for a parameters list (e.g., in a method declaration).
SJava_ParametersDef :: SimpleJavaGrammar

-- | Rule for arguments passed to a method call (e.g., <tt>(1 + 2, "arg2",
--   null)</tt>).
SJava_Args :: SimpleJavaGrammar

-- | Rule for a sequential list of statements (e.g., inside a method).
SJava_Statements :: SimpleJavaGrammar

-- | Rule for a statement that is a single expression (e.g., <tt>x +=
--   3</tt> that also returns the new value of <tt>x</tt> is an expression
--   statement).
SJava_ExprStatement :: SimpleJavaGrammar

-- | Rule for assignments of variables (e.g., <tt>x = 3</tt>).
SJava_Assignment :: SimpleJavaGrammar

-- | Rule for <tt>return</tt> statements.
SJava_Return :: SimpleJavaGrammar

-- | Rule for conditions (<tt>if</tt>).
SJava_Condition :: SimpleJavaGrammar

-- | Rule for function calls.
SJava_FuncCall :: SimpleJavaGrammar

-- | Rule for expressions (e.g., <tt>1 + 1</tt>).
SJava_Expression :: SimpleJavaGrammar

-- | Rule for unary operations (e.g., <tt>!</tt> or <tt>-</tt>).
SJava_UnaryOp :: SimpleJavaGrammar

-- | Rule for binary operations (e.g., <tt>+</tt> or <tt>*</tt>).
SJava_BinaryOp :: SimpleJavaGrammar

-- | Rule for variable declarations (e.g., <tt>int x;</tt>).
SJava_VarDecl :: SimpleJavaGrammar

-- | Rule for variable references.
SJava_VarRef :: SimpleJavaGrammar

-- | Rule for literals.
SJava_Literal :: SimpleJavaGrammar

-- | Rule for types (e.g., <tt>int</tt> in <tt>int x;</tt>).
SJava_Type :: SimpleJavaGrammar

-- | Rule that represents an entire file. Usually the root of the AST.
SJava_File :: SimpleJavaGrammar

-- | An AST build from the SimpleJavaGrammar.
type SJavaAST a = AST SimpleJavaGrammar a

-- | An AST build from the SimpleJavaGrammar containing Strings as values.
type SSJavaAST = SJavaAST String

-- | A <a>SSJavaAST</a> whose nodes are not yet assigned their UUIDs (they
--   are still states waiting for evaluation).
type SJavaState = Tree (State UUID (Node SimpleJavaGrammar String))

-- | Construct a method definition with given (1) return type, (2) name,
--   (3) parameters (pairs of type and name), and (4) the given content
--   (list of statements).
sjava_methoddef :: String -> String -> [(String, String)] -> [SJavaState] -> SJavaState

-- | Construct a definition of parameters subtree from the given pairs of
--   type and name.
sjava_parametersdef :: [(String, String)] -> SJavaState

-- | Construct an arguments subtree from the given list of subtrees (e.g.,
--   <tt>(1 + 2, "arg2", null)</tt>).
sjava_args :: [SJavaState] -> SJavaState

-- | Construct a statements block from a list of statements.
sjava_statements :: [SJavaState] -> SJavaState

-- | Wrap the given subtree in an expression statement. The given tree
--   should be an expression. Pseudocode example: <tt>sjava_exprstatement
--   'x += 3 == 'x + 3;'</tt>.
sjava_exprstatement :: SJavaState -> SJavaState

-- | Constructs an assignment where parameter (1) represents the left side
--   of the assignment (e.g., a variable that should be assigned a value),
--   (2) is the operator's name to use (e.g., <tt>"="</tt>), and (3) is the
--   expression to assign (e.g. "1 + 2").
sjava_assignment :: SJavaState -> String -> SJavaState -> SJavaState

-- | Constructs a return statement that returns the given expression.
sjava_return :: SJavaState -> SJavaState

-- | Constructs an if-block (without else case) with the given condition
--   (first argument) and sequence of statements to run when the condition
--   is met.
sjava_condition :: SJavaState -> [SJavaState] -> SJavaState

-- | Constructs a call to a function the given name and a list of arguments
--   to pass.
sjava_funccall :: String -> [SJavaState] -> SJavaState

-- | Wraps an tree in an expression. For example, a literal is an
--   expression. Thus a literal can be used anywhere an expression required
--   but should be wrapped into an expression first.
sjava_expr :: SJavaState -> SJavaState

-- | Constructs a unary operation (e.g. <tt>-3</tt>) from a given name
--   (<tt>-</tt>) that is applied to the given expression (<tt>3</tt>).
sjava_unaryop :: String -> SJavaState -> SJavaState

-- | Constructs a binary operator from a given name and two expressions.
sjava_binaryop :: SJavaState -> String -> SJavaState -> SJavaState

-- | Constructs a variable declaration (e.g., <tt>int x;</tt>) from a type
--   (e.g., <tt>int</tt>) and a name (e.g., <tt>x</tt>).
sjava_vardecl :: String -> String -> SJavaState

-- | Constructs a reference to a variable with the given name. The returned
--   tree is a leaf.
sjava_varref :: String -> SJavaState

-- | Constructs a literal with the given name. The returned tree is a leaf.
sjava_literal :: String -> SJavaState

-- | Constructs a type with the given name. The returned tree is a leaf.
sjava_type :: String -> SJavaState

-- | Constructs a file with the given name and content.
sjava_file :: String -> [SJavaState] -> SJavaState
instance GHC.Show.Show SimpleJava.SimpleJavaGrammar
instance GHC.Classes.Eq SimpleJava.SimpleJavaGrammar
instance Grammar.Grammar SimpleJava.SimpleJavaGrammar
instance ASTPrettyPrinter.ASTPrettyPrinter SimpleJava.SimpleJavaGrammar

module StackPopAlice
feature_SafeStack :: Feature
feature_ImmutableStack :: Feature
featurecolours :: MonadColorPrinter m => FeatureFormulaColourPalette m
startTree :: State UUID SSJavaAST
condTree :: State UUID SSJavaAST
cloneDef :: State UUID SSJavaAST
cloneStorage :: State UUID SSJavaAST
cloneRetStatement :: State UUID SSJavaAST
newReturnType :: String
example :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)

module StackPopBob
featureColourPalette :: MonadColorPrinter m => FeatureFormulaColourPalette m -> FeatureFormulaColourPalette m
example :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)

module EditPatterns
feature_ULTRA_LCD :: Feature
feature_FOO :: Feature
rootName :: String
buildPCName :: String -> FeatureFormula -> String
featurecolours :: MonadColorPrinter m => FeatureFormulaColourPalette m
emptyfile :: State UUID SSJavaAST
lcd_setstatusalertpgm :: State UUID SSJavaAST
alertstatuspgm :: State UUID SSJavaAST
somefunction :: State UUID SSJavaAST
createPatternExample :: MonadColorPrinter m => String -> SSJavaAST -> History SimpleJavaGrammar String -> Example m SimpleJavaGrammar String
createPatternExampleWithStartTrace :: MonadColorPrinter m => FeatureTrace SimpleJavaGrammar String -> String -> SSJavaAST -> History SimpleJavaGrammar String -> Example m SimpleJavaGrammar String
addIfdef :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addIfdefWithPC :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addIfdefElse_IfBranch :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addIfdefElse_IfBranchWithPC :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addIfdefElse_ElseBranch :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addIfdefElse_ElseBranchWithPC :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addIfdefWrapElse :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addIfdefWrapThen :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addNormalCode_nonvariational :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
addNormalCode_outerpc :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
remNormalCode_null :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
remNormalCode_notnull :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)
remIfdef :: MonadColorPrinter m => State UUID (Example m SimpleJavaGrammar String)

module Main
data CodePrintStyle
ShowAST :: CodePrintStyle
ShowCode :: CodePrintStyle
ShowTikz :: CodePrintStyle
data TraceDisplay
Trace :: TraceDisplay
PC :: TraceDisplay
data TraceStyle
Text :: TraceStyle
Colour :: TraceStyle
None :: TraceStyle
data OutputFormat
OutputFormat :: CodePrintStyle -> TraceDisplay -> TraceStyle -> Bool -> OutputFormat
[codeStyle] :: OutputFormat -> CodePrintStyle
[traceDisplay] :: OutputFormat -> TraceDisplay
[traceStyle] :: OutputFormat -> TraceStyle
[withTraceLines] :: OutputFormat -> Bool

-- | The perspective of the developer who is editing code while traces are
--   recorded in the background This is the format used in the figures in
--   the paper.
userFormat :: OutputFormat

-- | A variation of <a>userFormat</a> where traces and presence conditions
--   can be investigated seperately at the same time. Code is coloured in
--   the colour of its trace while presence conditions are indicated by
--   coloured lines on the left.
userFormatDetailed :: OutputFormat

-- | Shows the Abstract Syntax Tree of the source code with feature traces
--   as formulas.
astFormat :: OutputFormat

-- | Tikz export of AST with traces. Used for figures in the paper.
tikzFormat :: OutputFormat
main :: IO ()
showExamples :: IO ()
headline :: MonadColorPrinter m => String -> m ()
finalizeExample :: State UUID (Example m g a) -> Example m g a
runStepwise :: (MonadColorPrinter m, Grammar g, ASTPrettyPrinter g) => OutputFormat -> State UUID (Example m g String) -> m ()
printASTWithTrace :: (MonadColorPrinter m, Grammar g, ASTPrettyPrinter g, Show a, Eq a) => OutputFormat -> FeatureFormulaColourPalette m -> AST g a -> FeatureTrace g a -> Doc (Attribute m)
printTraces :: (MonadColorPrinter m, Grammar g, ASTPrettyPrinter g, Show a, Eq a) => OutputFormat -> Example m g a -> [(FeatureTrace g a, AST g a)] -> Doc (Attribute m)
alsoShowInitialStateInHistory :: History g a -> History g a
propositional_values :: [PropositionalFormula String]
nullableFormula_values :: [NullableFormula String]
showTruthtables :: IO ()
instance GHC.Classes.Eq Main.TraceStyle
instance GHC.Show.Show Main.TraceStyle
instance GHC.Classes.Eq Main.TraceDisplay
instance GHC.Show.Show Main.TraceDisplay
instance GHC.Show.Show Main.CodePrintStyle
