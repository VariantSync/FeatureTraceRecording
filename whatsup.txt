//- Plain nodes should not have presence conditions at all. These nodes need to be exactly present in those variants in which their parent has to be present.
- How to remove redundancies in ftr: For each node v in delta: F(v) <- Simplify.removeRedundancy (PC of nearest ancestor legator) F(v)
- Können wir immer und überal mit PCs rechnen statt der Traces, wo wir jetzt Redundanzen entfernen koennen?
- Look at ASTT_BinaryOp:
    - It is NOT constituent because it canot be removed without invalidating its parent (which is always of type Expression).
    - BUT it could be replaced in another clone with another ASTT_BinaryOp. For instance, "==" in one variant and "!=" in another variant.
    - Questions:
      - Do we need a better classification of nodes apart from Plain | Constituent | Legator?
      - Which other node types are there with these problems?
      - If we allow such a node to be traced, how can we ensure that one instance of this type of node will be present in each variant?
      - If we do not allow such a node to be traced, how can we ensure it to have the correct presence condition?
        For example, given "if (a == 0)", then "==" has no trace because its plain.
        It should be present in all variants where the condition "if" is present though. So we need:
          PC ("if") => PC ("==") because if cannot exist without a valid expression.
          PC ("==") => PC ("if") because an expression cannot exist in the void.
        This gives us the requirement PC ("==") = PC ("if").
        But, "if" is constituent. So "==" does not inherit the trace of the if!
        How to handle this issue?